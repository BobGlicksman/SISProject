"use strict"; // turn on strict mode

/* A set of functions to be used in testing the SIS from a web page.
  The web page should contain blank divs with the following id values:
    1. deviceListOutput
    2. debugLog
    3. functionButtons
    4. variableButtons
  External Calls to Spark.io:
     initWebPage() if there is anything to do
     logAdd(string) will add the string to the top of a time
        stamped list in a div with the id debugLog
     logClear() clears the debugLog div
     loginToSpark() brings up the modal form and starts the
        retrieval of all the attributes of the selected core
     listAllDevices() will display a list of registered devices
        in a div with the id deviceListOutput and populate buttons
        and text boxes in functionButtons and variableButtons
        activeDeviceSet() set the window.activeDevice variable to be
        the selected device from spark.device[ ].
     listAttributes() refreshes the Actions list for the selected core
     callSparkCoreFunctionFromHTMLButton(functionToCall) places a
        call to the spark.io API. The return code from the spark.io
        API is returned.
     getSparkCoreVariableFromHTMLButton(variableToGet) places a call
        to the spark.io API. The value we get back is returned, and placed
        in a global variable in the module.
   External Calls to handle Spark Core communication
     getSensorLog() obtain the most recent sensor events
     getSensorConfig() obtain the currently configured sensors
   Other External Calls
     startMonitoring() in case the persistent event monitor closes
        you can call this from your browser's console. Don't know why the
        connection closes. At some point we'll figure that out and this
        call will remain internal.


(c) 2015 Jim Schrempp
*/

// Module Globals
if (typeof SHRIMPWARE === "undefined") {
  var SHRIMPWARE = {};
} // Start of module declaration
SHRIMPWARE.SISTest = (function() { // private module variables
  var _version = 16 // Now relies on Config string from the Spark Core (v15 or later)
                    // v12 adds setMode for SIS or ConfigSmallApartment
                    // v14 supports multiple cores
                    // v15 reads circ buffer 0 up and stops on null return
                    //     general UI clean up
                    //     UI now generated by _eType constant
                    // v16 adds save config button
                    // v17 bug fixes on output of config buttons.

    , _expectedSISCoreVersion = 20 // this Javascript expects this SIS code in the core

    , _mainLoop = undefined  // timer that pops every 0.5 seconds, all the time
    , _startDate = new Date()
    , _activeDevice = undefined
    , _sparkCoreData = // used to hold the data that comes back from the spark core
        {
            SensorLog: [],
            SensorLogIsRefreshed: false,
            SensorConfig: [],
            SensorConfigIsRefreshed: false,
            LastSensorTrip: ''
        }
    , _lastHeartbeat = undefined
    , _attributes = undefined // how does this work when there is more than one core?

    , _lastHandledPublishedEventNum = 0
    // the last event number that has been handled
    // so we don't handle old published events
    // should probably have one per eventName

    , _animationTimer1Sec // when screen needs to be animated, this pops once a second

    , _defaultBtnStyle // module functions

    , _sensorPositionBeingConfigured = -1

    , _sensorDescriptionBeingConfigured = ''

    , _eMode = {
        DoNothing : {},
        SIS : {value: 0, name: "SIS", sensorList: ""},
        ConfigSmallApartment: {value: 1, name: "ConfigSmallApartment", sensorList: ""}
    }
    , _eType = {   // Sensor layout
        Generic: [
            {pos: 0, label: "FrontRoomPIR", display: "Front Room PIR"},
            {pos: 1, label: "BedRoomPIR",   display: "Bed Room PIR"},
            {pos: 2, label: "BathPIR",      display: "Bath Room PIR"},
            {pos: 3, label: "HallwayPIR",   display: "Hallway PIR"},
            {pos: 4, label: "FrontDoorSep", display: "Front Door Separation"}
        ],
        Saratoga: [
            {pos: 0, label: "FrontRoomPIR",  display: "Front Room PIR"},
            {pos: 1, label: "MasterBedPIR",  display: "Master Bed Room PIR"},
            {pos: 2, label: "SecondBedPIR",  display: "Second Bed Room PIR"},
            {pos: 3, label: "KitchenPIR",    display: "Kitchen PIR"},
            {pos: 4, label: "UpperHallPIR",  display: "Upper Hall PIR"},
            {pos: 5, label: "FrontDoorSep",  display: "Front Door Separation"},
            {pos: 6, label: "GarageDoorSep", display: "Garage Door Separation"}
        ],
        ElmStreet: [
            {pos: 0, label: "FrontRoomPIR",  display: "Front Room PIR"},
            {pos: 1, label: "JimsRoomPIR",   display: "Jim's Office PIR"},
            {pos: 2, label: "KitchenPIR",   display: "Kitchen PIR"},
            {pos: 3, label: "MasterBRPIR",   display: "MasterBR PIR"},
            {pos: 4, label: "LivingroomPIR",   display: "Livingroom PIR"},
            {pos: 5, label: "FrontDoorSep",  display: "Front Door Separation"},
            {pos: 6, label: "BackDoorSep",  display: "Back Door Separation"},
            {pos: 8, label: "OnePersonHome",  display: "One Person Home"},
            {pos: 9, label: "TwoPeopleHome",  display: "Two People Home"},
            {pos: 10, label: "NoOneHome",  display: "No One Home"}
        ]
    }

    , _mode = _eMode.SIS    // 0 = SIS  1 = ConfigSmallApartment

    ;
  var

    setMode = function(modeValue) {
        switch (modeValue) {
        case "":
        case "SIS":
            _mode = _eMode.SIS;
            break;
        case "ConfigSmallApartment":
            _mode = _eMode.ConfigSmallApartment;
            _mode.sensorList = _eType.Generic;
            break;
        case "ConfigSaratoga":
            _mode = _eMode.ConfigSmallApartment;
            _mode.sensorList = _eType.Saratoga;
            break;
        case "ConfigElmStreet":
            _mode = _eMode.ConfigSmallApartment;
            _mode.sensorList = _eType.ElmStreet;
            break;
        default:
            alert ('Your web page must call SHRIMPWARE.SIS.setMode with SIS or ConfigSmallApartment');
            _mode = _eMode.DoNothing;
            break;
        };
    },

    setType = function(modeType) {
        switch (modeType){
        case "Default":
            _mode.type = ""
        }

    },

    initWebPage = function() {
        logAdd("Entered initWebPage");
        document.getElementById("jbs_jsversion").innerHTML = "version " + _version;
        document.getElementById("btnListAllDevices").disabled = true;
        disableDeviceButtons(true);
        _defaultBtnStyle = document.getElementById("btnGetSensorLog").style;
        switch (_mode.name) {
        case "":
        case "SIS":

            break;
        case "ConfigSmallApartment":
            document.getElementById("currentSensorDiv").style.display = "none";
            document.getElementById("newSensorSetupDiv").style.display = "none";
            document.getElementById("commandsDiv").style.display = "none";
            document.getElementById("sensorActivityDiv").style.display = "none";
            document.getElementById("debugLogDiv").style.display = "none";
            makeSensorEntrySelectForm();
            makeSensorLiveDisplay();
            break;
        }
        _mainLoop = setInterval(mainLoopTimerPop,500);
        //_startDate = new Date();
    },

    disableDeviceButtons = function(isDisabled) {
        // God, I hate negative logical variable names!
        switch(_mode.name) {
        case "":
        case "SIS":
            document.getElementById("btnGetAttributes").disabled = isDisabled;
            document.getElementById("btnGetSensorConfig").disabled = isDisabled;
            break;
        case "ConfigSmallApartment":
            var ele = document.getElementsByName("sensor");
            for(var i=0;i<ele.length;i++) {
                ele[i].checked = isDisabled;
                //ele[i].disabled = isEnabled;
            }
            var visibilityState = "block";
            if (isDisabled) visibilityState = "none";
            document.getElementById("sensorSelectDiv").style.display = visibilityState;
            document.getElementById("sensorActivityDiv").style.display = visibilityState;


            break;
        }
        document.getElementById("btnGetSensorLog").disabled = isDisabled;
        document.getElementById("btnAnalyzeSensorLog").disabled = isDisabled;
    },
    logAdd = function(message) {
        // adds message to top of the div debugLog with a timestamp
      var currentTime = new Date();
      currentTime = currentTime.getHours() + ":" + currentTime.getMinutes()
            + ":" + currentTime.getSeconds() + "." + currentTime.getMilliseconds();
      currentTime = currentTime.valueOf();
      var logElement = document.getElementById("debugLog");
      var currentLog = logElement.innerHTML;
      currentLog = currentTime + " " + message + "<br>" + currentLog;
      logElement.innerHTML = currentLog;
    },
    logClear = function() {
      document.getElementById("debugLog").innerHTML = "";
    },
    debugShow = function() {
        document.getElementById("debugLogDiv").style.display = "block";
        document.getElementById("debugShowBtn").style.display = "none";
    },
    commandOutputAdd = function(message) {
        // adds message to top of the div debugLog with a timestamp
      var logElement = document.getElementById("commandOutput");
      var currentLog = logElement.innerHTML;
      currentLog = message + "<br>" + currentLog;
      logElement.innerHTML = currentLog;
    },
    commandOutputClear = function() {
        document.getElementById("commandOutput").innerHTML = "";
    },
    errorMessageAdd = function(message) {
        var logElement = document.getElementById("errorMessages");
        var currentLog = logElement.innerHTML;
        currentLog = message + "<br>" + currentLog;
        logElement.innerHTML = currentLog;
    },

    sensorConfigOutputAdd = function(message) {
        // adds message to top of the div debugLog with a timestamp
        var logElement = document.getElementById("sensorConfigOutput");
        var currentLog = logElement.innerHTML;
        currentLog = message + "<br>" + currentLog;
        logElement.innerHTML = currentLog;
    },
    sensorConfigOutputClear = function() {
        document.getElementById("sensorConfigOutput").innerHTML = "";
    },

    // ------------------------------------------------------------------------
    // MAIN TIMER LOOP
    //

    mainLoopTimerPop = function() {
        // this is called every 0.5 seconds, all the time
        var rightNow = new Date();
        var elapsedMillis = rightNow - _startDate;
        if ( elapsedMillis > 10000) {
            // it's been long enough for the heartbeat to start
            if (rightNow - _lastHeartbeat > 25000) {
                if (_mode.name == "ConfigSmallApartment") {
                    var elem = document.getElementById("eventHeartbeat");
                    elem.style.background = "#ff0000";
                    var i = 1;
                    // why didn't this work?
                    // signalHeartbeatError();
                }
            }
        }
    },


    // ---------- Spark Login -----------
    loginToSpark = function() {
        // displays a button "Login To Spark" in a div on the page
        // with id="spark-login".  When the user
        // clicks that button and finishes logging in, the function is called.
      sparkLogin(sparkLoginComplete);
    },
    sparkLoginComplete = function(data) {
      logAdd("back from sparklogin");
      listAllDevices();
    },

    // ------------------ List Devices ------------------
    listAllDevices = function() {
        // query spark.io for an updated list of devices
      logAdd("In listAllDevices");
      document.getElementById("btnListAllDevices").disabled = true;
      var devicesPr = spark.listDevices();
      devicesPr.then(devicesPrTrue, devicesPrFalse);
    },
    devicesPrTrue = function(devices) {
        //we are here when the device information is available
        //so we list information in a div with id="deviceListOutput"
      console.log('Devices: ', devices);
      var outputElement = document.getElementById("deviceListOutput");
      //display all the devices on the web page
      var devlist = spark.devices;
      var output = 'Select a device<br><form >';
      var coreState = "";
      devlist.forEach(function(entry) {
        var connectedValue = "";
        if (entry.connected) {
          _sparkCoreData.connectedValue = true;
          coreState = "Online";
        } else {
          _sparkCoreData.connectedValue = false;
          coreState = "Offline";
        }
        output = output +
            '<input type="radio" name="device" value= "' + entry.id  +
            '" onClick="SHRIMPWARE.SISTest.activeDeviceSet(' + "'" +
            entry.id + "')" + '">&nbsp;'
            + entry.name + " <b>id:</b> " + entry.id + " <b>"
            + coreState + "</b><br>";
      });

      outputElement.innerHTML = output;
      getAttributes();
    },
    devicesPrFalse = function(err) {
      logAdd('List devices call failed: ', err);
      document.getElementById("btnListAllDevices").disabled = false;
    },


    //------------- Get Attributes ------------------
    getAttributes = function() {
        // Now get all attributes
      logAdd('in getAttributes');
      var attributesPr = spark.getAttributesForAll();
      // NOTE: The above call should do a remote get to the spark.io web site
      // but in the browser console I do not see this happening.
      attributesPr.then(attributesPrTrue, attributesPrFalse);
      document.getElementById("btnListAllDevices").disabled = false;
    },
    attributesPrTrue = function(data) {
        //we are here when the attribute information is available
      logAdd("get attributes succeeded");
      console.log("attributes: ", data);
      _attributes = data;
      // XXX testing device selection from form
      // activeDeviceSet(); // set the device we will be using
    },
    attributesPrFalse = function(err) {
      logAdd("get attributes failed");
    },
    activeDeviceSet = function(idWeWant) {
        // set the global device variable for other functions to use
        // eventually should pop a dialog for user to pick a device
        // for now we just pick device 0
      logAdd("In activeDeviceSet");
      var devList = spark.devices;
      // look throught devList to find the device the user selected
      var selectedDevice = -1;
      for (var i=0; i < devList.length; i++) {

          if (devList[i].id == idWeWant) {
              selectedDevice = i;
              break;
          }
      }

      if (selectedDevice == -1) {
          logAdd("activeDeviceSet error: device not in list");
      } else {
          logAdd("Active device is: " + devList[selectedDevice].name);
          _activeDevice = spark.devices[selectedDevice];

          console.log("Active device: " + _activeDevice);
          console.log('Device name: ' + _activeDevice.name);
          console.log('- connected?: ' + _activeDevice.connected);
          if (_activeDevice.connected) {
              listAttributes();
          } else {
              document.getElementById("deviceListOutput").innerHTML +=
                                "<br>Your Selected Core Is OFFLINE.";
          }
          logAdd("---");
          startMonitoring();    //start listening for events
      }
      /*    // is this intended for core to core communication?
      //subscribe to events from this device
       spark.listDevices().then(function(devices) {
                   devices[0].onEvent('SISEvent',
                   function(data) {
                    console.log("Event: " + data);
                    });
                    });
      */
    },
    listAttributes = function() {
        //retrive the functions and variables that the core supports
        //and populate buttons for each on the web page
        //console.log("global activedevice: ", _activeDevice);
        //console.log("global attributes: ", attributes);
      logAdd("in listAttributes");
      if (_mode == _eMode.SIS) {
          disableDeviceButtons(true);
          _attributes.forEach(function(entry) {
              console.log(entry);

              if (entry.id == _activeDevice.id) {
                  // create the buttons to call each available Spark.function
                  var functionButtons = "";
                  for (var x in entry.functions) {
                      var functionName = entry.functions[x];
                      logAdd("Function: " + functionName);
                      functionButtons += formatCallButton(functionName)
                      //console.log(functionButtons);
                  }
                  document.getElementById("functionButtons").innerHTML = functionButtons;
                  // create the buttons to retrieve each available Spark.variable
                  var variableButtons = '';
                  for (var x in entry.variables) {
                      var variableName = entry.variables[x];
                      logAdd("Variable: " + x + " type: " + variableName);
                      variableButtons += formatRetrieveButton(x);
                  }
                  document.getElementById("variableButtons").innerHTML = variableButtons;
              }

          });
      }
      disableDeviceButtons(false);
      commandOutputClear();
      sensorConfigOutputClear();
      getCoreConfiguration();
    },

    // --------------------------------------------------------------------
    // ------- Monitor the spark api for events.
    //
    //
    startMonitoring = function() {
        // call only when _activeDevice is defined (after selectActiveDevice)
        logAdd("entered startMonitoring");
        var eventMonitor = new XMLHttpRequest();
        eventMonitor.onreadystatechange = function() {

            signalHeartbeat();

            if (eventMonitor.readyState == 4) {

                errorMessageAdd("Event monitor stream has closed.");
            }

            var data = eventMonitor.responseText;
            //console.log(data);
            if (data.length > 5) {
                processPublishNotificationGroup(data);
            }
        }

        // listen to only the selected device
        var accessToken = window.spark.accessToken;
        eventMonitor.open("GET", "https://api.spark.io/v1/devices/"
            + _activeDevice.id + "/events/SISEvent?access_token="
            + accessToken , true);
        eventMonitor.send();
        /*        if(typeof(EventSource) !== "undefined") {
          //var source = new EventSource("demo_sse.php");
                   Spark.getEventStream(false, 'mine', function(data) {
                                 console.log("Event: " + data);            });
        //source.onmessage = function(event) {
        //    addLog(event.data);
        //};
        } else {
               logAdd("Browser does not support server-sent events...");
                  }
        */
    },
    signalHeartbeat = function() {

        _lastHeartbeat = new Date();

        if (_mode.name == "ConfigSmallApartment") {
            var heartbeat = document.getElementById("eventHeartbeat");
            var hbState = heartbeat.getAttribute("data-state");
            if (hbState == "OFF") {
                heartbeat.style.background = "#00ff00";
                heartbeat.setAttribute("data-state", "ON");
            }
            setTimeout(function() {
                heartbeat.style.background = "#ffffff";
                heartbeat.setAttribute("data-state", "OFF");
            },500);
        };
    },
    signalHeartbeatError = function() {
        document.getElementById("eventHeartbeat").style.background = "#ff0000";
    },
    processPublishNotificationGroup = function(data) {

      var eventRows = data.split("\n");
      for (var i = 0; i < eventRows.length; i++) {
        console.log("testing row" + i + "  " + eventRows[i]);
        if (eventRows[i].substring(0, 4) == "data") {
          var eventName = eventRows[i - 1];
          eventName = eventName.substring(7, eventName.length);
          var eventData = eventRows[i];
          eventData = eventData.substring(6, eventData.length);
          try {
            eventData = JSON.parse(eventData);
            processPublishEvent(eventName, eventData);
          } catch (err) {
            logAdd(err);
            logAdd("Error parsing SparkIO event JSON");
            return;
          }
        }
      }
    },
    processPublishEvent = function(eventName, eventData) {
        // Now we have something to work with!
      try {
        //console.log(eventName);
        //console.log(eventData.data);
        var sisEvent = JSON.parse(eventData.data);
      } catch (err) {
        logAdd(err);
        logAdd("Error parsing SIS event JSON");
        return;
      }
      //console.log(sisEvent);
      // if the event is newer than the last one we handled,
      // the go get the sensor log.
        if (Number(sisEvent.eventNum) > Number(_lastHandledPublishedEventNum)) {
            _lastHandledPublishedEventNum = sisEvent.eventNum;
            //getSensorLog(); // should eventually call analyze log here.
            switch (_mode.name) {
            case '':
            case 'SIS':
                alertSISEventReceived();
                break;
            case 'ConfigSmallApartment':
                var sensorLocation = Number(sisEvent.sensorLocation);
                sensorTripStartAnimation(sensorLocation);
                break;
            }
        }
    },
    alertSISEventReceived = function() { //alert("SIS Sensor Trip Event");
      styleAButton("btnGetSensorLog", 3);
      styleTheAlert(3);

      /*  var popUpDiv = document.createElement("div");
          popUpDiv.innerHTML =        "
          <DIV id='PopUp' style='display: none; position: absolute; left: 100px; top: 50px; "
          +        " border: solid black 1px; padding: 10px; background-color: rgb(200,100,100); "
          +        " text-align: justify; font-size: 12px; width: 135px;' "
          +        " onmouseover="document.getElementById('PopUp').style.display = 'none' ">
              <SPAN id='PopUpText'>TEXT</SPAN>        </DIV>";        document.body.append(popUpDiv);
      */
    },


    // ------------------------------------------------------------------------
    // -------- Retrieve Spark Core Configuration --------
    //
    getCoreConfiguration = function(junk) {
      getSparkCoreVariable("Config", storeCoreConfiguration);
    },
    storeCoreConfiguration = function(data) {
      // store the core configuration

      var configParsed = _sparkCoreData.Config.split(",");
      for (var i = 0; i < configParsed.length; i++) {
        var paramParsed = configParsed[i].split(":");
        _sparkCoreData[paramParsed[0].trim()] = paramParsed[1].trim();
      }
      validateCoreConfig();
      if (_mode == _eMode.SIS) {
          displaySparkConfig();
      }
      return;

      function validateCoreConfig() {
        var expectedConfigParams = {
          cBufLen: "num",
          MaxSensors: "num",
          version: "num",
          utcOffset: "num",
          DSTyn: "y/n",
          resetAt: "epoc"
        };

        // Test case below. All params should be errors and one missing
        //var expectedConfigParams = {cBufLen:"y/n", MaxSensors:"y/n", version:"y/n",
        //    utcOffset:"y/n", DST:"num", reset:"y/n", MissingTest:"num", RealErrorCase:"abc"};
        //console.log("Running test code in validateCoreConfig - errors expected");
        var errorMessages = "";
        // fix up resetAT epoc time.
        if (_sparkCoreData.hasOwnProperty("resetAt")) {
          _sparkCoreData["resetAt"] = _sparkCoreData["resetAt"].replace("Z", "");
        }
        for (var paramName in expectedConfigParams) {
          if (!expectedConfigParams.hasOwnProperty(paramName)) continue;
          var paramValue = _sparkCoreData[paramName];
          var expectedParamType = expectedConfigParams[paramName];
          if (!paramName) {
            errorMessages += "<br>Error: did not find config param: " + paramName;
          } else {
            switch (expectedParamType) {
              case "num":
                if (isNaN(paramValue)) {
                  errorMessages += "<br>Error: param " + paramName + ": "
                            + paramValue + " must be a number";
                }
                break;
              case "y/n":
                if (paramValue != 'yes' && paramValue != 'no') {
                  errorMessages += "<br>Error: param " + paramName + ": "
                            + paramValue + " must be yes/no";
                }
                break;
              case "epoc":
                if (isNaN(paramValue)) {
                  errorMessages += "<br>Error: param " + paramName + ": "
                            + paramValue + " must be a number";
                  break;
                }
                if (paramValue < 1420150996) {
                  errorMessages += "<br>Warning: param " + paramName + ": "
                            + paramValue + " seems too small for epoc time.";
                }
                break;
              default:
              // you must have added a parameter type to the array and not updated
              // this switch statement.
                errorMessages += "<br>Error: 1 Javascript problem in validateCoreConfig.";
            }
          }
        } // end for
        if (_sparkCoreData.version != _expectedSISCoreVersion) {
          errorMessages += "<br>Warning: Expected SIS firmware version: "
                            + _expectedSISCoreVersion;
        }
        if (errorMessages != "") {
            errorMessageAdd(errorMessages);
        }
      }
    },
    displaySparkConfig = function() {
        // A human readable summary of the spark core configuration
        document.getElementById("currentCoreConfig").innerHTML = "";
        var dateInSISTZ = new Date(Number(_sparkCoreData.resetAt) * 1000);
        var dateInUTC = new Date((Number(_sparkCoreData.resetAt)
                        - Number(_sparkCoreData.utcOffset) * 3600) * 1000);
        var output = '';
        output += "<br>SIS firmware version: " + _sparkCoreData.version;
        output += "<br>Last Reset (SIS local time): " + dateInSISTZ.toLocaleString();
        output += "  (" + _sparkCoreData.utcOffset + ")";
        output += "<br>Last Reset (UTC time)" + dateInUTC.toLocaleString();
        output += "<br>Core locale observes Daylight Savings Time? " + _sparkCoreData.DSTyn;
        output += "<br>Core retains last " + _sparkCoreData.cBufLen + " sensor events.";
        output += "<br>"
        document.getElementById("currentCoreConfig").innerHTML += output;
    },

    // ------------------------------------------------------------------------
    // -------- Sensor log -----------------------
    //
    getSensorLog = function() {

        // iterate through the sensor log on the Spark core and display results
      styleAButton("btnGetSensorLog", 2);
      commandOutputClear();
      commandOutputAdd("Retrieving Sensor Log");
      _sparkCoreData.SensorLogIsRefreshed = false;
      _sparkCoreData.SensorLog = [];
      iterateSensorLog(-1);
    },
    iterateSensorLog = function(buffPosition) {
        // This is called recusively!!!
        // Retrieve the sensor log at buffPosition, then when done call this
        // again with buffPosition-1. Stop when buffPosition is < 0.
        // Start by calling this with the length of the sensor log.
      buffPosition = buffPosition + 1;
      if (buffPosition > _sparkCoreData.cBufLen) {
        logAdd("buffPosition is now greater than bufferLength");
        _sparkCoreData.SensorLogIsRefreshed = true;
        commandOutputAdd("--end of sensor buffer--");
        styleAButton("btnGetSensorLog", 1);
        styleTheAlert(1);
      } else {
        callSparkCoreFunction("ReadBuffer", buffPosition, function(data) {
          if (data < 0) {
            logAdd("error calling ReadBuffer, " + buffPosition);
          } else {
            getSparkCoreVariable("circularBuff", function(data) {

              if (data) {

                commandOutputAdd(data);
                _sparkCoreData.SensorLog[_sparkCoreData.SensorLog.length] = data;
                iterateSensorLog(buffPosition);

              } else {

                // else data was nil and we've reached the last valid
                // buffer entry
                commandOutputAdd("--end of sensor log--");
                styleAButton("btnGetSensorLog", 1);
                styleTheAlert(1);

              }

            });
          }
        });
      }
    },

    // ------- Sensor Configuration ------------------

    getSensorConfig = function(callWhenDone, passBackData) {
        // iterate through the sensor log on the SIS and display results
      sensorConfigOutputClear();
      _sparkCoreData.SensorConfigIsRefreshed = false;
      _sparkCoreData.SensorConfig = [];
      iterateSensorConfig(_sparkCoreData.MaxSensors, callWhenDone, passBackData);
    },
    iterateSensorConfig = function(buffPosition, callWhenDone, passBackData) {
        // This is called recusively!!!
        // Retrieve the sensor config at buffPosition, then when done call this
        // again with buffPosition-1. Stop when buffPosition is < 0.
        // Start by calling this with the length of the sensor config array on
        // the spark core.
      buffPosition = buffPosition - 1;
      if (buffPosition < 0) {
          //here when we are done with recusion
        logAdd("buffPosition is less than 0");
        _sparkCoreData.SensorConfigIsRefreshed = true;
        if (callWhenDone) callWhenDone(passBackData);

      } else {
        var commandParam = "read, " + buffPosition;
        callSparkCoreFunction("Register", commandParam, function(data) {
          if (data < 0) {
            logAdd("error calling registration, " + buffPosition);
          } else {
            getSparkCoreVariable("registration", function(data) {
              if (data) {
                  sensorConfigOutputAdd(data);
                _sparkCoreData.SensorConfig[_sparkCoreData.SensorConfig.length] = data;
              }
              iterateSensorConfig(buffPosition, callWhenDone, passBackData);
            });
          }
        });
      }
    },

    // -----------------------------------------------------------------------
    // -------  Specific Code for ConfigSmallApartment --------------
    //
    showASensor = function(sensorPosition, sensorDescription) {

        document.getElementById("currentSensorDiv").style.display = "block";
        document.getElementById("newSensorSetupDiv").style.display = "block";
        document.getElementById("commandsDiv").style.display = "block";
        resetSensorRegButtons();

        document.getElementById("currentSensorInfo").innerHTML =
                        "Getting current config, please wait.";
        var commandParam = "read, " + sensorPosition;
        callSparkCoreFunction("Register", commandParam, function(data) {
            if (data < 0) {
                logAdd('Error getting sensor position in showASensor');
            } else {
                getSparkCoreVariable("registration", function(data) {
                    if (!data) {
                        logAdd('Error2 getting sensor data in showASensor');
                    } else {
                        document.getElementById("currentSensorInfo").innerHTML = data;
                        _sensorPositionBeingConfigured = sensorPosition;
                        _sensorDescriptionBeingConfigured = sensorDescription;
                        logAdd('Ready to configure sensor loc: ', sensorPosition);
                    };
                });
            }
        });
    },
    setNewSensorBegin = function(){
        //read the last sensor trip to make sure the next time we read it
        //it will be the new sensor

        document.getElementById('sensorConfigOutput').innerHTML = '';
        getSparkCoreVariable("sensorTrip", function(data) {

            if (!data) {
                // had some read error
            } else {
                _sparkCoreData.LastSensorTrip = data;
                document.getElementById('btnSetNewSensorWasTripped').disabled = false;
                document.getElementById('btnSetNewSensorBegin').disabled = true;
            }
        });
    },
    resetSensorRegButtons = function() {

        document.getElementById('btnSetNewSensorWasTripped').disabled = true;
        document.getElementById('btnSetNewSensorBegin').disabled = false;

    },
    setNewSensorWasTripped = function() {
        // read the sensor trip.
        // Be sure it is new.
        // Parse out the new sensor id
        // Then stuff it in the slot we are configuring.
        // Have SIS save config.

        var msgElement = document.getElementById('sensorConfigOutput');
        // read the sensor trip
        getSparkCoreVariable("sensorTrip", function(data) {

            if (!data) {
                // had some read error
            } else {
                // be sure it is a new sensor trip
                // TODO: SIS should add a sequence number or date to the sensorTrip so we know if it is a new one
                //if (_sparkCoreData.LastSensorTrip == data) {
                if (false) {
                    // data is same as last time
                    msgElement.innerHTML =
                        "<br>New sensor trip was not detected. Try again.";

                } else {
                    // is it an unregistered sensor?

                    if (data.indexOf("unknown") == -1) {
                        msgElement.innerHTML =
                            "<br>Detected sensor is already configured."
                            + " If this is the correct sensor, then remove it from the config first. Sensor id: "
                            + 'xxx';

                    } else {
                        // parse out the new sensor id
                        var sensorIdStart = data.indexOf("code:") + 6;
                        var sensorIdEnd = data.indexOf(" ",sensorIdStart);
                        var sensorId = data.substring(sensorIdStart,sensorIdEnd);

                        // have SIS add it into the configuration
                        var commandParam = 'register,' + _sensorPositionBeingConfigured
                            + ',' + sensorId + ',' + _sensorDescriptionBeingConfigured;

                        callSparkCoreFunction("Register", commandParam, function(data) {
                            if (data != 4) {
                                // some error
                                msgElement.innerHTML =
                                    "<br>Error from SIS Register: " + data;
                            } else {
                                // Now command SIS to save its config automatically?
                                // TODO
                                msgElement.innerHTML = '<br>Sensor was successfully registered!';

                            }


                        });

                    }

                }
            }
            resetSensorRegButtons();
        });

    },
    clearSensorConfig = function() {
        for (var i=0; i<15; i++) {
            var commandParam = "register," + i + "," + i + ",unknown";
            logAdd(commandParam);
            callSparkCoreFunction("Register",commandParam, function(i) {
                logAdd("Sensor Config position cleared:" + i);
            }
        )}

        var msgElement = document.getElementById('sensorConfigOutput').innerHTML =
            "<br>Sensor Config was cleared.";

    },
    saveSensorConfig = function() {

        var msgElement = document.getElementById('sensorConfigOutput');
        var commandParam = "store,1,1,1";
        callSparkCoreFunction("Register", commandParam, function(data) {
            if (data != 4) {
                // some error
                document.getElementById('sensorConfigOutput').innerHTML =
                    "Error from SIS Register: " + data;
            } else {
                msgElement.innerHTML = '<br>Sensor setup was successfully saved.';
            }

        });

    },


    sensorTripStartAnimation = function(sensorLocation) {
        // call this to decorate a sensor text on the screen
        // The animation will slowly degrade the color.
        var showSensorActive = document.getElementsByClassName('showSensorActive');
        for (var i=0; i < showSensorActive.length; i++) {

            // using the name property
            var thisSensorActive = showSensorActive[i];
            if (Number(thisSensorActive.attributes.name.value) == sensorLocation) {

                thisSensorActive.style.background = "#00C0FF";
                thisSensorActive.setAttribute("data-animating","YES");

                sensorActiveAnimate();
                break;

            }
        }
    },

    sensorActiveAnimate = function() {
        if (_animationTimer1Sec) return;

        _animationTimer1Sec = setInterval(function() {
            // degrade the decoration of all sensor text
            var needsAnimation = false;
            var showSensorActive = document.getElementsByClassName('showSensorActive');
            for (var i=0; i < showSensorActive.length; i++) {
            //for (var showSensor in showSensorActive) {

                var thisSensorActive = showSensorActive[i];
                var animating = thisSensorActive.getAttribute("data-animating");
                if (animating == "YES") {
                    needsAnimation = true; //not done yet
                    thisSensorActive.style.background = "#ffffff";
                    thisSensorActive.setAttribute("data-animating", "NO");
                    break;

                }
            }
            if (!needsAnimation) {
                clearInterval(_animationTimer1Sec);
                _animationTimer1Sec =  null;
            }

        }, 1000);
    },





    // --------------------------------------------------------------
    //-------  To call a Spark.function or retrieve a Spark.variable
    //
    getSparkCoreVariable = function(variableToGet, callbackFunction) {
        // This routine calls out to a Spark Core to retrieve a variable
        //should make sure _activeDevice is not null
      _sparkCoreData[variableToGet] = "waiting to get value";
      _activeDevice.getVariable(variableToGet, function(err, data) {
        var returnValue;
        if (err) {
          logAdd("error getting variable" + data); // is this right?
          returnValue = "error" + data;
        } else {
          var message = variableToGet + " current value: " + data.result;
          logAdd(message);
          returnValue = data.result;
        }
        _sparkCoreData[variableToGet] = returnValue;
        callbackFunction(returnValue);
      });
    },
    getSparkCoreVariableFromHTMLButton = function(variableToGet) {
        // call this from a button
      document.getElementById(variableToGet + "Return").value = "waiting";
      var message = getSparkCoreVariable(variableToGet, function(data) {
        document.getElementById(variableToGet + "Return").value = data;
      });
    },
    callSparkCoreFunction = function(functionToCall, stringToSend, callbackFunction) {
        // This routine calls a Spark Core Function and puts the return code from the call
        // in the global array g_htmlValues //should make sure g_activeDevice is not null
      logAdd("Calling Spark Core Function " + functionToCall + " with data: " + stringToSend);
      _sparkCoreData[functionToCall] = "waiting for call to complete";
      _activeDevice.call(functionToCall, stringToSend, function(err, data) {
        var returnValue;
        if (err) {
          logAdd("Error calling function: " + functionToCall + ": " + data)
          // is this right
          returnValue = "error";
        } else {
          logAdd("Back from calling Spark Core Function");
          returnValue = data.return_value;
          console.log("result ", data);
          // seems like return value is always 0...
        }
        _sparkCoreData[functionToCall] = returnValue;
        callbackFunction(returnValue);
      });
    },
    callSparkCoreFunctionFromHTMLButton = function(functionToCall) {
        // This routine pulls the string to send from the HTML document, calls the
        // Spark core function
      var stringToSend = document.getElementById(functionToCall + "Input").value;
      document.getElementById(functionToCall + "Return").value = "waiting";
      var answer = callSparkCoreFunction(functionToCall, stringToSend, function(data) {
        document.getElementById(functionToCall + "Return").value = data;
      });
    },

    // -------------- Utility Functions ------------
    styleAButton = function(btnName, mode) {
        // pass in a button name
        // pass in mode 1,2,3  1:rtn to normal, 2:yellow, 3:red
      var theBtn = document.getElementById(btnName);
      switch (mode) {
        case 1:
          theBtn.style = _defaultBtnStyle;
          break;
        case 2:
          theBtn.style.backgroundColor = '#ffff00';
          break;
        case 3:
          theBtn.style.backgroundColor = '#ff0000';
          break;
        default:
          theBtn.style.backgroundColor = '#000000';
          break;
      }
    },
    styleTheAlert = function(mode) {
        // pass in mode 1,2,3  1:rtn to normal, 3:red
      return; // not using this now
      var theAlert = document.getElementById("eventReceived");
      switch (mode) {
        case 1:
          theAlert.visibility = 'hidden';
          break;
        case 3:
          theAlert.visibility = 'visible';
          break;
          defaul:
            theAlert.visibility = 'hidden';
          break;
      }
    },
    formatCallButton = function(sparkFunctionName) {
      /*
      This function returns HTML with one button and two text boxes similar to this:
              <button onclick="callSparkCoreFunctionFromHTMLButton('ReadBuffer')">
              Call ReadBuffer</button>
              &nbsp;&nbsp;
              Input: <input type="text" id="ReadBufferInput" size="15" >
              <br>RtnCode: <input type="text" id="ReadBufferReturn" size="5" >
              <p>
     */
      var sparkFunctionNameData = sparkFunctionName + 'Input';
      var sparkFunctionNameReturn = sparkFunctionName + 'Return';
      var output = '<button onclick="SHRIMPWARE.SISTest.callSparkCoreFunctionFromHTMLButton('
      + "'" + sparkFunctionName + "')" + '"' + "> Call " + sparkFunctionName
      + '</button>' + "&nbsp;&nbsp;" + 'Input: <input type="text" id="'
      + sparkFunctionNameData + '" size="25" >' + '<br>RtnCode: <input type="text" id="'
      + sparkFunctionNameReturn + '" size="5" ><p>';
      //console.log(output);
      return output;
    },
    formatRetrieveButton = function(sparkVariableName) {
      /*
      This function returns HTML with one button and one text box similar to this:
              <button onclick="variableGet('Buffer_Size')">
              Retrieve Buffer_Size</button>
              <input id="Buffer_SizeReturn" type="text" size="45">
      */
      var sparkVariableNameReturn = sparkVariableName + "Return";
      var output = '<button onclick="SHRIMPWARE.SISTest.getSparkCoreVariableFromHTMLButton('
      + "'" + sparkVariableName + "'" + ')"> Retrieve ' + sparkVariableName
      + '</button>' + "&nbsp;&nbsp;" + '<input type="text" id="'
      + sparkVariableNameReturn + '" size="45" ><p>';
      return output;
    },
    makeSensorEntrySelectForm = function() {

        var msg = '<form>';
        for (var i in _mode.sensorList) {
            msg += makeSensorEntrySelect(_mode.sensorList[i].pos,
                                         _mode.sensorList[i].label,
                                         _mode.sensorList[i].display);
        };
        msg += '</form>';

        document.getElementById('sensorList').innerHTML = msg;
        console.log(msg);


    },
    makeSensorEntrySelect = function(position, SISName, displayName) {

        var msg = "<input type='radio' name='sensor' onClick='SHRIMPWARE.SISTest.showASensor("
            + position + ', "' + SISName + '"' + ")'  >" + displayName + "<br>";
        return msg;

    },

    makeSensorLiveDisplay = function() {
        var msg = '';
        for (var i in _mode.sensorList) {
            msg += '<p class="showSensorActive" name="';
            msg += _mode.sensorList[i].pos;
            msg += '">';
            msg += _mode.sensorList[i].display;
            msg += '</p>';
        }
        document.getElementById('sensorActivityDiv').innerHTML = msg;
    },

    analyzeSensorLog = function() {
      commandOutputClear();
      commandOutputAdd("This comes from the routine where I would add analysis.");
      var msg = "Sensor log has " + _sparkCoreData.SensorLog.length + " entries in it."
      commandOutputAdd(msg);
    }
  return {
      // public methods and properties
    loginToSpark: loginToSpark,
    initWebPage: initWebPage,
    listAllDevices: listAllDevices,
    getAttributes: getAttributes,
    getSensorLog: getSensorLog,
    getSensorConfig: getSensorConfig,
    analyzeSensorLog: analyzeSensorLog,
    activeDeviceSet: activeDeviceSet,
    logClear: logClear,
    callSparkCoreFunctionFromHTMLButton: callSparkCoreFunctionFromHTMLButton,
    getSparkCoreVariableFromHTMLButton: getSparkCoreVariableFromHTMLButton,
    setMode: setMode,
    showASensor: showASensor,
    setNewSensorBegin: setNewSensorBegin,
    setNewSensorWasTripped: setNewSensorWasTripped,
    debugShow: debugShow,
    startMonitoring: startMonitoring,
    saveSensorConfig:saveSensorConfig,
    clearSensorConfig:clearSensorConfig
  };
}());
